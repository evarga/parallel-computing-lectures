#
# Source: Udacity - Introduction to Computing course (project assignment).
# The code below is my solution to the assignment, and I use it to
# introduce the major elements of Python 3.
#

"""
A one-dimensional cellular automaton takes in a string, which in our
case, consists of the characters '.' and 'x', and changes it according
to some predetermined rules. The rules consider three characters, which
are a character at position k and its two neighbours, and determine
what the character at the corresponding position k will be in the new
string.

For example, if the character at position k in the string  is '.' and
its neighbours are '.' and 'x', then the pattern is '..x'. We look up
'..x' in the table below. In the table, '..x' corresponds to 'x' which
means that in the new string, 'x' will be at position k.

Rules:
         pattern in         position k in        contribution to
Value    current string     new string           pattern number
                                                 is 0 if replaced by '.'
                                                 and value if replaced
                                                 by 'x'
  1       '...'               '.'                        1 * 0
  2       '..x'               'x'                        2 * 1
  4       '.x.'               'x'                        4 * 1
  8       '.xx'               'x'                        8 * 1
 16       'x..'               '.'                       16 * 0
 32       'x.x'               '.'                       32 * 0
 64       'xx.'               '.'                       64 * 0
128       'xxx'               'x'                      128 * 1
                                                       -------
                                                           142

To calculate the patterns which will have the central character x, work
out the values required to sum to the pattern number. For example,
32 = 32 so only pattern 32 which is x.x changes the central position to
an x. All the others have a . in the next line.

23 = 16 + 4 + 2 + 1 which means that 'x..', '.x.', '..x' and '...' all
lead to an 'x' in the next line and the rest have a '.'

For pattern 142, and starting string
...........x...........
the new strings created will be
..........xx...........  (generations = 1)
.........xx............  (generations = 2)
........xx.............  (generations = 3)
.......xx..............  (generations = 4)
......xx...............  (generations = 5)
.....xx................  (generations = 6)
....xx.................  (generations = 7)
...xx..................  (generations = 8)
..xx...................  (generations = 9)
.xx....................  (generations = 10)

Note that the first position of the string is next to the last position
in the string.

Define a method, final_state, that takes two inputs:
    a pattern number which is an integer between 0 and 255 that
represents a set of rules, and
    a positive integer, n, which is the number of generations.
The method should return a string which is the result of
applying the rules generated by the pattern to the initial string n times.
The initial string is the argument to the constructor.
"""


class CellularAutomaton:
    """Implements a one-dimensional cellular automaton according to the specification."""

    PATTERNS = ('...', '..x', '.x.', '.xx', 'x..', 'x.x', 'xx.', 'xxx')

    def __init__(self, cells):
        self._cells = cells

    @staticmethod
    def _get_rules(pattern_number):
        """
        Returns back a set with patterns that transition to 'x'
        based upon the pattern number.
        """

        rules = set()
        value = 128
        for i in range(7, -1, -1):
            if pattern_number >= value:
                rules.add(CellularAutomaton.PATTERNS[i])
                pattern_number -= value
            value >>= 1
        return rules

    @staticmethod
    def _read_state(cells, position):
        """Reads out the state of cells at the given position."""

        num_cells = len(cells)
        return cells[(position - 1) % num_cells] + cells[position] + cells[(position + 1) % num_cells]

    def final_state(self, pattern_number, num_generations):
        rules = CellularAutomaton._get_rules(pattern_number)
        cells = self._cells
        num_cells = len(cells)

        for _ in range(num_generations):
            new_cells = list(cells)
            for i in range(num_cells):
                pattern = CellularAutomaton._read_state(cells, i)
                new_cells[i] = 'x' if pattern in rules else '.'
            cells = ''.join(new_cells)
        return cells


#
# HOMEWORK: Convert these into real unit tests. The desired output is reflected in commented out sections.
#
print(CellularAutomaton._get_rules(32))
#>>> set(['x.x'])
print(CellularAutomaton._get_rules(23))
#>>> set(['..x', '...', '.x.', 'x..'])
print(CellularAutomaton._get_rules(142))
#>>> set(['..x', 'xxx', '.xx', '.x.'])

print(CellularAutomaton._read_state('.x.x.x.x.', 0))
#>>> ..x
print(CellularAutomaton._read_state('.x.x.x.x.', 8))
#>>> x..
print(CellularAutomaton._read_state('.x.x.x.x.', 5))
#>>> .x.

ca = CellularAutomaton('.x.x.x.x.')
print(ca.final_state(17, 2))
#>>> xxxxxxx..
print(ca.final_state(249, 3))
#>>> .x..x.x.x

ca = CellularAutomaton('...x....')
print(ca.final_state(125, 1))
#>>> xx.xxxxx
print(ca.final_state(125, 2))
#>>> .xxx....
print(ca.final_state(125, 3))
#>>> .x.xxxxx
print(ca.final_state(125, 4))
#>>> xxxx...x
print(ca.final_state(125, 5))
#>>> ...xxx.x
print(ca.final_state(125, 6))
#>>> xx.x.xxx
print(ca.final_state(125, 7))
#>>> .xxxxx..
print(ca.final_state(125, 8))
#>>> .x...xxx
print(ca.final_state(125, 9))
#>>> xxxx.x.x
print(ca.final_state(125, 10))
#>>> ...xxxxx
